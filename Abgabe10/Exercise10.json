{
  "version": 1,
  "title": "Image Processing",
  "description": "",
  "programs": [
    {
      "version": 1,
      "name": "Rendering Pass",
      "vertex": "#version 100\n\nprecision mediump float;\n\nattribute vec3 v_Position;\nattribute vec3 v_Normal;\n\nuniform mat4 modelView;\nuniform mat4 projection;\n\nvarying vec3 normal;\n\nvoid main() {\n    gl_Position = projection * modelView * vec4(v_Position, 1);\n    normal = (modelView * vec4(v_Normal, 0.0)).xyz;\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\nvarying vec3 normal;\n\nvoid main() {\n    gl_FragColor = vec4(0.5 * (normalize(normal) + 1.0), gl_FragCoord.z);\n}",
      "isDefault": true
    },
    {
      "version": 1,
      "name": "Compose Pass",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\n\nuniform mat4 modelViewProjection;\nuniform vec2 halfSizeNear;\nuniform mat4 sceneView;\nuniform vec3 lightPos;\n\nvarying vec2 uv;\nvarying vec3 eyeDirection;\nvarying vec3 light;\n\nvoid main() {\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n    uv.xy = v_Position.xy;\n    eyeDirection = vec3((2.0 * halfSizeNear * uv.xy) - halfSizeNear , -1.0);\n    light = (sceneView * vec4(lightPos, 1.0)).xyz;\n}",
      "fragment": "#version 100\n\nprecision highp float;\n\nconst float emission = 600.0;\nconst vec3 ka = vec3(0.05, 0.05, 0.05);\nconst vec3 kd = vec3(0.4, 0.4, 0.4);\nconst vec3 ks = vec3(1.0, 1.0, 1.0);\nconst float alpha = 5.0;\n\nuniform sampler2D sampler;\nuniform mat4 sceneProjection;\n\nvarying vec2 uv;\nvarying vec3 eyeDirection;\nvarying vec3 light;\n\nvec4 getEyePosition(float bufferZ) {\n    float ndcZ = 2.0 * bufferZ - 1.0;\n    float eyeZ = sceneProjection[3][2] / ((sceneProjection[2][3] * ndcZ) - sceneProjection[2][2]);\n    return vec4(eyeDirection * eyeZ, 1);\n}\n\nvec3 phong(vec3 l, vec3 n) {\n    float d = length(l);\n    vec3 ln = l / d;\n    vec3 r = reflect(-ln, n);\n    float intensity = 1.0/(d*d);\n    float diff = clamp(dot(ln,n), 0.0, 1.0);\n    float spec = clamp(pow(clamp(r.z, 0.0, 1.0), alpha), 0.0, 1.0);\n    return ka + (kd * diff + ks * spec) * intensity * emission;\n}\n\nvoid main() {\n    vec3 normal = 2.0 * texture2D(sampler, uv).xyz - 1.0;\n    vec3 eyePos = -getEyePosition(texture2D(sampler, uv).w).xyz;\n\n    vec3 color;\n    if (length(normal) < 0.5) {\n        color = vec3(0.9, 0.9, 0.9);\n    } else {\n        color = phong(light - eyePos, normal);\n    }\n\n    gl_FragColor = vec4(color, 1.0);\n}",
      "isDefault": false
    },
    {
      "version": 1,
      "name": "Smoothing Pass",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\n\nuniform mat4 modelViewProjection;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n    uv.xy = v_Position.xy;\n}",
      "fragment": "#version 100\n\nprecision highp float;\n\nuniform sampler2D inputImage;\nuniform sampler2D smoothingKernel;\nuniform float viewWidth;\nuniform float viewHeight;\nuniform bool vertical;\n\nvarying vec2 uv;\n\nvoid main() {\n    vec4 resultColor = vec4(0.0);\n\n    for (int d = 0; d < 7; ++d) {\n        vec2 kernelUV = vec2(float(d) / 7.0 + 1.0 / 14.0, 0.5);\n        vec2 imageUV = vec2(float(d) / viewWidth - 3.0 / viewWidth, 0.0);\n\n        if (vertical) {\n            imageUV = imageUV.yx;\n        }\n\n        imageUV += uv;\n        resultColor += texture2D(smoothingKernel, kernelUV).x * texture2D(inputImage, imageUV);\n    }\n\n    gl_FragColor = resultColor;\n}",
      "isDefault": false
    }
  ],
  "javascript": "function getBoxKernel() {\n    var c = 1.0 / 7.0;\n    return [c, c, c, c, c, c, c];\n}\n\nfunction getGaussKernel() {\n    return [0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006];\n}\n\nfunction getSmoothingTexture(c, kernel) {\n    var tex = new c.models.Texture(c, {min: c.gl.LINEAR, mag: c.gl.LINEAR});\n    tex.data(c, 7, 1, new Float32Array([\n        kernel[0], 0.0, 0.0, 0.0,\n        kernel[1], 0.0, 0.0, 0.0,\n        kernel[2], 0.0, 0.0, 0.0,\n        kernel[3], 0.0, 0.0, 0.0,\n        kernel[4], 0.0, 0.0, 0.0,\n        kernel[5], 0.0, 0.0, 0.0,\n        kernel[6], 0.0, 0.0, 0.0\n        ]), {\n        type: c.gl.FLOAT\n    });\n    return tex;\n}\n\nfunction extensions(c) {\n    // Enable float textures.\n    this.extensions = c.requireExtensions([\n        'OES_texture_float'\n    ]);\n}\n\nfunction ui(c) {\n    var ui = c.ui;\n\n    ui.add(ui.grid({\n        children: [\n            // theta slider in range [0, pi]\n            ui.label({ value: 'Light (Theta Angle):', title: 'Theta Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'theta'],\n                min: 0.0,\n                max: Math.PI\n            }),\n            // phi slider in range [0, 2pi]\n            ui.label({ value: 'Light (Phi Angle):', title: 'Phi Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'phi'],\n                min: 0.0,\n                max: 2.0 * Math.PI\n            }),\n            // radius slider in range [0, 100]\n            ui.label({ value: 'Light (Radius):', title: 'Light Distance' }),\n            ui.slider({\n                bind: [this.light, 'radius'],\n                min: 20.0,\n                max: 40.0\n            })\n        ]\n    }), { left: 10, bottom: 6 });\n\n    ui.add(ui.grid({\n        children: [\n            // Choice of smoothing kernel\n            ui.label({ value: 'Smoothing kernel: ', title: 'Choice of smoothing kernel' }),\n            ui.multiswitch({\n                values: [\"Box\", \"Gauss\"],\n                bind: [this, \"kernel\"]\n            }),\n            // smoothing iterations slider\n            ui.label({ value: 'Smoothing iterations:', title: 'Smoothing iterations' }),\n            ui.slider({\n                bind: [this, 'iterations'],\n                min: 1,\n                max: 10\n            }),\n        ]\n    }), { right: 10, bottom: 6 });\n}\n\nfunction init(c) {\n    this.view = c.models.View.perspective(c, 45, null, 0.01, 50, {\n        buffer: {color: {texture: {type: c.gl.FLOAT}}}\n    });\n\n    // halbe near plane groesse berechnen\n    var viewport = this.view.currentViewport();\n    var aspect = viewport[2] / viewport[3];\n    var fovy = 45.0 * Math.PI / 180.0;\n    this.halfSizeNear = c.math.vec2(0.0, Math.tan(fovy / 2.0));\n    this.halfSizeNear[0] = aspect * this.halfSizeNear[1];\n\n    this.view.color = c.math.vec4(0.5, 0.5, 0.5, 0);\n\n    this.model = c.models.Model.load(c, \"local:teapot.obj\");\n\n    var r = -Math.PI;\n    this.view.transform.rotateY(1.3*r).rotateX(r/6).translateForward(8).translateUp(1);\n\n    this.fview = c.models.View.orthographic(c, null, -1, 1, {interactive: false});\n\n    this.quad = new c.models.Quad(c, [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]);\n\n    this.light = { theta: 1.0, phi: 0.6, radius: 30.0 }\n    this.iterations = 1;\n\n    this.qview0 = c.models.View.orthographic(c, null, -1, 1, {\n        interactive: false,\n        buffer: {color: {texture: {type: c.gl.FLOAT}}}\n    });\n\n    this.qview1 = c.models.View.orthographic(c, null, -1, 1, {\n        interactive: false,\n        buffer: {color: {texture: {type: c.gl.FLOAT}}}\n    });\n\n    this.boxTexture = getSmoothingTexture(c, getBoxKernel());\n    this.gaussTexture = getSmoothingTexture(c, getGaussKernel());\n\n    this.kernel = \"Box\";\n\n    ui.call(this, c);\n}\n\nfunction render(c) {\n    // geometry pass\n    c.view(this.view);\n    this.model.render(c);\n\n    // compose pass\n    c.view(this.qview0);\n\n    var lightPos = c.math.vec3(\n        this.light.radius * Math.cos(this.light.phi) * Math.sin(this.light.theta),\n        this.light.radius * Math.cos(this.light.theta),\n        this.light.radius * Math.sin(this.light.phi) * Math.sin(this.light.theta)\n    );\n\n    var viewMatrix = c.math.mat4.fromTransform(c.math.mat4.create(), this.view.originTransform());\n\n    this.quad.material.program = \"Compose Pass\";\n\n    this.quad.render(c, {\n        uniforms: {\n            sampler: this.view.activeBufferTexture('color'),\n            halfSizeNear: this.halfSizeNear,\n            sceneProjection: this.view.projection(),\n            sceneView: viewMatrix,\n            lightPos: lightPos\n        }\n    });\n\n    this.quad.material.program = \"Smoothing Pass\";\n\n    var smoothingTexture;\n    if (this.kernel == \"Box\") {\n        smoothingTexture = this.boxTexture;\n    } else {\n        smoothingTexture = this.gaussTexture;\n    }\n    var viewport = this.view.currentViewport();\n    var iterations = Math.floor(this.iterations);\n    for (var i = 0; i < iterations; ++i) {\n        c.view(this.qview1);\n\n        this.quad.render(c, {\n            uniforms: {\n                smoothingKernel: smoothingTexture,\n                inputImage: this.qview0.activeBufferTexture('color'),\n                viewWidth: viewport[2],\n                viewHeight: viewport[3],\n                vertical: true\n            }\n        });\n\n        // Im letzten Pass in den Ausgabebuffer rendern.\n        // Ansonsten zwischen qview0 und qview1 wechseln.\n        if (i == iterations-1) {\n            c.view(this.fview);\n        } else {\n            c.view(this.qview0);\n        }\n\n        var viewport = this.view.currentViewport();\n\n        this.quad.render(c, {\n            uniforms: {\n                smoothingKernel: smoothingTexture,\n                inputImage: this.qview1.activeBufferTexture('color'),\n                viewWidth: viewport[2],\n                viewHeight: viewport[3],\n                vertical: false\n            }\n        });\n    }\n}\n",
  "creationTime": "2014-10-13T17:41:46.792Z",
  "authors": [
    {
      "name": "Jesse van den Kieboom",
      "license": "CC BY",
      "year": 2014
    }
  ]
}