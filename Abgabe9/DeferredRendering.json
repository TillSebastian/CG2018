{
  "version": 1,
  "title": "Deferred Rendering",
  "description": "",
  "programs": [
    {
      "version": 1,
      "name": "Rendering Pass",
      "vertex": "#version 100\n\n\nprecision mediump float;\n\nattribute 
vec3 v_Position;\nattribute vec3 v_Normal;\n\nuniform mat4 modelView;\nuniform mat4 projection;\n\nvarying vec3 normal;\n\nvoid main() {\n    gl_Position = projection * modelView * vec4(v_Position, 1);\n    normal = (modelView * vec4(v_Normal, 0.0)).xyz;\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\nvarying vec3 normal;\n\nvoid main() {\n    gl_FragColor = vec4(0.5 * (normalize(normal) + 1.0), gl_FragCoord.z);\n}",
      "isDefault": true
    },
    {
      "version": 1,
      "name": "Compose Pass",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\n\nuniform mat4 modelViewProjection;\nuniform vec2 halfSizeNear;\nuniform mat4 sceneView;\nuniform vec3 lightPos;\n\nvarying vec2 uv;\nvarying vec3 eyeDirection;\nvarying vec3 light;\n\nvoid main() {\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n    uv.xy = v_Position.xy;\n    eyeDirection = vec3((2.0 * halfSizeNear * uv.xy) - halfSizeNear , -1.0);\n    light = (sceneView * vec4(lightPos, 1.0)).xyz;\n}",
      "fragment": "#version 100\n\nprecision highp float;\n\nconst float emission = 600.0;\nconst vec3 ka = vec3(0.05, 0.05, 0.05);\nconst vec3 kd = vec3(0.4, 0.4, 0.4);\nconst vec3 ks = vec3(1.0, 1.0, 1.0);\nconst float alpha = 5.0;\n\nuniform sampler2D sampler;\nuniform mat4 sceneProjection;\n\nvarying vec2 uv;\nvarying vec3 eyeDirection;\nvarying vec3 light;\n\nvec4 getEyePosition(float bufferZ) {\n    float ndcZ = 2.0 * bufferZ - 1.0;\n    float eyeZ = sceneProjection[3][2] / ((sceneProjection[2][3] * ndcZ) - sceneProjection[2][2]);\n    return vec4(eyeDirection * eyeZ, 1);\n}\n\nvec3 phong(vec3 l, vec3 n) {\n    float d = length(l);\n    vec3 ln = l / d;\n    vec3 r = reflect(-ln, n);\n    float intensity = 1.0/(d*d);\n    float diff = clamp(dot(ln,n), 0.0, 1.0);\n    float spec = clamp(pow(clamp(r.z, 0.0, 1.0), alpha), 0.0, 1.0);\n    return ka + (kd * diff + ks * spec) * intensity * emission;\n}\n\nvoid main() {\n    vec3 normal = 2.0 * texture2D(sampler, uv).xyz - 1.0;\n    vec3 eyePos = -getEyePosition(texture2D(sampler, uv).w).xyz;\n\n    vec3 color;\n    if (length(normal) < 0.5) {\n        color = vec3(0.6, 0.6, 0.6);\n    } else {\n        color = phong(light - eyePos, normal);\n    }\n\n    gl_FragColor = vec4(color, 1.0);\n}",
      "isDefault": false
    }
  ],
  "javascript": "function extensions(c) {\n    // We use floating point textures since they're nicer.\n    this.extensions = c.requireExtensions([\n        'OES_texture_float'\n    ]);\n}\n\nfunction ui(c) {\n    var ui = c.ui;\n\n    ui.add(ui.grid({\n        children: [\n            // theta slider in range [0, pi]\n            ui.label({ value: 'Light (Theta Angle):', title: 'Theta Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'theta'],\n                min: 0.0,\n                max: Math.PI\n            }),\n            // phi slider in range [0, 2pi]\n            ui.label({ value: 'Light (Phi Angle):', title: 'Phi Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'phi'],\n                min: 0.0,\n                max: 2.0 * Math.PI\n            }),\n            // radius slider in range [0, 100]\n            ui.label({ value: 'Light (Radius):', title: 'Light Distance' }),\n            ui.slider({\n                bind: [this.light, 'radius'],\n                min: 20.0,\n                max: 40.0\n            })\n        ]\n    }), { left: 10, bottom: 6 });\n}\n\nfunction init(c) {\n    this.view = c.models.View.perspective(c, 45, null, 0.01, 50, {\n        buffer: {color: {texture: {type: c.gl.FLOAT}}}\n    });\n\n    // Compute half of the near plane size\n    var viewport = this.view.currentViewport();\n    var aspect = viewport[2] / viewport[3];\n    var fovy = 45.0 * Math.PI / 180.0;\n    this.halfSizeNear = c.math.vec2(0.0, Math.tan(fovy / 2.0));\n    this.halfSizeNear[0] = aspect * this.halfSizeNear[1];\n\n    // The background color. It should be noted that this is the content of the G-Buffer.\n    // Due to the way the normal is written the normal data of [0.5, 0.5, 0.5] results\n    // in a final normal of [0, 0, 0] in the second rendering pass. We then interpret\n    // such a normal as background.\n    this.view.color = c.math.vec4(0.5, 0.5, 0.5, 0);\n\n    this.model = c.models.Model.load(c, \"local:suzanne.obj\");\n    //this.model = new c.models.Box(c, 1, 1, 1);\n\n    var r = -Math.PI / 6;\n    this.view.transform.rotateY(r).rotateX(r).translateForward(3);\n\n    // full screen quad view\n    this.fview = c.models.View.orthographic(c, null, -1, 1, {interactive: false});\n    // the fullscreen quad\n    this.quad = new c.models.Quad(c, [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]);\n    this.quad.material.program = \"Compose Pass\";\n\n    this.light = { theta: 1.0, phi: 0.6, radius: 30.0 }\n\n    ui.call(this, c);\n}\n\nfunction render(c) {\n    // geometry pass\n    c.view(this.view);\n    this.model.render(c);\n\n    // compose pass\n    c.view(this.fview);\n\n    // Compute light position\n    var lightPos = c.math.vec3(\n        this.light.radius * Math.cos(this.light.phi) * Math.sin(this.light.theta),\n        this.light.radius * Math.cos(this.light.theta),\n        this.light.radius * Math.sin(this.light.phi) * Math.sin(this.light.theta)\n    );\n\n    // Render fullscreen quad\n    var viewMatrix = c.math.mat4.fromTransform(c.math.mat4.create(), this.view.originTransform());\n    this.quad.render(c, {\n        uniforms: {\n            sampler: this.view.activeBufferTexture('color'),\n            halfSizeNear: this.halfSizeNear,\n            sceneProjection: this.view.projection(),\n            sceneView: viewMatrix,\n            lightPos: lightPos\n        }\n    });\n}\n",
  "creationTime": "2014-10-13T17:41:46.792Z",
  "authors": [
    {
      "name": "Jesse van den Kieboom",
      "license": "CC BY",
      "year": 2014
    }
  ]
}
