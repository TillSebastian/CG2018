{
  "version": 1,
  "title": "Basic Shadow Mapping",
  "description": "",
  "programs": [
    {
      "version": 1,
      "name": "Render",
      "vertex": "#version 100\n\nuniform mat4 view;\nuniform mat4 model;\nuniform mat4 modelView;\nuniform mat4 modelViewProjection;\nuniform mat4 shadowViewProjection;\n\nuniform vec3 lightDirection;\n\nattribute vec3 v_Position;\nattribute vec3 v_Normal;\n\nvarying vec3 f_Position;\nvarying vec3 f_Normal;\nvarying vec3 f_Leye;\nvarying vec3 f_H;\n\nvarying highp vec4 f_ShadowCoord;\n\nvoid main() {\n    // Normal in eye space\n    f_Normal = mat3(modelView) * v_Normal;\n\n    // Light direction in eye space\n    f_Leye = mat3(view) * lightDirection;\n\n    // Half vector in eye space\n    f_H = normalize(vec3(0, 0, 1) - f_Leye);\n\n    // TASK: Here you need to transform the vertex into the coordinate\n    // system of the light (the \"shadow camera\").\n    // Don't forget that the model matrix also needs to be applied\n    // even though it doesn't have an effect in this case).\n    f_ShadowCoord =  shadowViewProjection *model * vec4(v_Position, 1);\n\n    // We also transform the vertex, as usual, into the camera coordinate system.\n    f_Position = (model * vec4(v_Position, 1)).xyz;\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\nuniform sampler2D shadowMap;\n\nvarying vec3 f_Position;\nvarying vec3 f_Normal;\nvarying vec3 f_Leye;\nvarying vec3 f_H;\n\nvarying highp vec4 f_ShadowCoord;\n\nstruct ColorComponent {\n    vec4  color;\n    float intensity;\n};\n\nstruct SpecularComponent {\n    vec4  color;\n    float intensity;\n    float hardness;\n};\n\nstruct Material {\n    ColorComponent    ambient;\n    ColorComponent    diffuse;\n    SpecularComponent specular;\n};\n\nuniform Material material;\n\nuniform float shadowBias;\n\n// Blinn-Phong\nvec3 specularTerm(vec3 N) {\n    float NdotHV = max(dot(N, f_H), 0.0);\n\n    return vec3(pow(NdotHV, material.specular.hardness)) * material.specular.color.rgb * material.specular.intensity;\n}\n\nfloat inShadow() {\n    // TASK:\n    // Depth comparison. Don't forget the shadowBias!\n    // The function should return 1.0 if fragment is in shadow, 0.0 otherwise.\n    float visibility = 0.0;\n    if (texture2D(shadowMap,f_ShadowCoord.xy).z > (f_ShadowCoord.z+shadowBias)){\n    visibility = 1.0;\n}\n\n    return visibility;\n}\n\nvoid main() {\n    // Ambient part\n    gl_FragColor.rgb = material.ambient.color.rgb * material.ambient.intensity;\n    gl_FragColor.a = 1.0;\n\n    // We interpolate the normal\n    vec3 N = normalize(f_Normal);\n\n    // Lambert\n    float NdotL = max(dot(N, -f_Leye), 0.0);\n\n    if (NdotL > 0.0) {\n        // Here inShadow() returns a boolean value as float (1.0 <=> fragment in shadow).\n        float visibility = 1.0 - inShadow();\n\n        // Diffuse part\n        vec3 diffuseTerm = NdotL * material.diffuse.color.rgb * material.diffuse.intensity;\n\n        // We assert that a little bit of light is preserved even in shadow such\n        // that we can roughly see the geometry.\n        gl_FragColor.rgb += diffuseTerm * clamp(visibility, 0.05, 1.0);\n\n        // Specular part (only if not in shadow).\n        if (visibility > 0.0) {\n            gl_FragColor.rgb += specularTerm(N) * visibility;\n        }\n    }\n}",
      "isDefault": true
    },
    {
      "version": 1,
      "name": "Render Shadow Map",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\n\nuniform mat4 modelViewProjection;\n\nvoid main() {\n    // Our goal is to transform the vertices into the coordinate system\n    // of our \"shadow camera\". Since the view matrix and projection matrix\n    // are already determined by the host code on the right hand side,\n    // we can perform this quite easily:\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\nvoid main() {\n    // We are only interested in the depth which is being computed and\n    // stored automatically by WebGL. We thus don't need any code here.\n}",
      "isDefault": false
    }
  ],
  "javascript": "function extensions(c) {\n    // We require the WEBGL_depth_texture extension to write the contents\n    // of the z-buffer into a texture. This extension is now implemented\n    // in all major browsers and can thus be used reliably.\n    this.exts = {\n        depth: c.requireExtension('WEBGL_depth_texture')\n    };\n}\n\nfunction ui(c) {\n    var ui = c.ui;\n\n    var ret = ui.add(ui.grid({\n        children: [\n            ui.label({ value: 'Shadow Map Resolution:', title: 'The resolution of the shadow map' }),\n            ui.multiswitch({\n                values: [256, 512, 1024, 2048],\n                bind: (function(_, v) {\n                    if (typeof v === 'undefined') {\n                        return this.shadowResolution;\n                    }\n\n                    this.shadowResolution = v;\n                    updateShadowResolution.call(this, c);\n                }).bind(this)\n            }),\n\n            ui.label({ value: 'Constant Shadow Bias:', title: 'The amount of constant depth bias to add when comparing depth values' }),\n            ui.slider({\n                bind: [this.uniforms, 'shadowBias'],\n                min: 0,\n                max: 0.05\n            }),\n\n            ui.label({ value: 'Slope Shadow Bias:', title: 'Enable shadow bias based on the slope by using glPolygonOffset' }),\n            ui.onoff({\n                bind: [this, 'slopeShadowBias']\n            }),\n\n            ui.label({ value: 'Light Direction Theta:', title: 'The direction of the light' }),\n            ui.slider({\n                bind: [this, 'lightRotationX'],\n                min: 0,\n                max: Math.PI\n            }),\n\n            ui.label({ value: 'Light Direction Phi:', title: 'The direction of the light' }),\n            ui.slider({\n                bind: [this, 'lightRotationY'],\n                min: 0,\n                max: 2.0 * Math.PI\n            })\n        ]\n    }), { left: 6, bottom: 6 });\n}\n\nfunction updateShadowResolution(c) {\n    // Scene from the direction of the light with orthographic projection (directional light).\n    // The viewport corresponds to the shadow map resolution. We also need to tell WebGL\n    // that we want a depth texture attachment which we can later forward as texture to\n    // the second render pass.\n    // Furthermore \"interactive: false\" results in mouse/keyboard input to be ignored\n    // to avoid changes in size of the render window (the viewport size should only\n    // depend on the shadow map resolution).\n    this.lightView = c.models.View.orthographic(c, [-6, 6, -6, 6], -6, 6, {\n        viewport: [0, 0, this.shadowResolution, this.shadowResolution],\n        buffer: {\n            depth: {\n                attachment: c.gl.DEPTH_STENCIL_ATTACHMENT,\n                texture: {\n                    format: c.gl.DEPTH_STENCIL,\n                    internalFormat: c.gl.DEPTH_STENCIL,\n                    type: this.exts.depth.UNSIGNED_INT_24_8_WEBGL\n                }\n            }\n        },\n        interactive: false\n    });\n}\n\nfunction buildScene(c) {\n    // Plane\n    this.plane = new c.models.Plane(c, 8, 8, {\n        doubleSided: true,\n        material: new c.models.Material({\n            diffuse: { color: c.math.vec4(1, 1, 1, 1), intensity: 1 },\n            specular: { intensity: 0 }\n        })\n    });\n    // Stretched box\n    this.box = new c.models.Box(c, 0.5, 3.0, 0.5);\n    this.box.transform.translate([-1.5, 1.5, 2]);\n    // Sphere\n    this.sphere = new c.models.UvSphere(c, 0.5, 24, 16);\n    this.sphere.transform.translate([1.5, 0.5, -1.5]);\n    // We collect the geometry in an array to easily iterate over it later.\n    this.models = [\n        this.box,\n        this.sphere,\n        this.plane\n    ];\n}\n\nfunction shadowTransform(c) {\n    var m = c.math;\n\n    // Theoretically we need the view matrix and the projection matrix\n    // of the \"shadow camera\" and could return projection * view, but...\n    var view = m.mat4.fromTransform$(this.lightView.originTransform());\n    var projection = this.lightView.projection();\n\n    // ... this transformation yields coordinates between -1 and 1. We address\n    // textures (and thus also our depth map) using coordinates between 0 and 1,\n    // therefore we multiply (from the left) with the matrix\n    // offset = 0.5   0   0 0.5\n    //            0 0.5   0 0.5\n    //            0   0 0.5 0.5\n    //            0   0   0 1.0\n    // where offset * x = (x+1)/2\n    // It should be noted that WebGL/OpenGL expects matrices in column-major format,\n    // therefore we write down the matrix in transposed order.\n    var offset = m.mat4(\n        0.5, 0.0, 0.0, 0.0,\n        0.0, 0.5, 0.0, 0.0,\n        0.0, 0.0, 0.5, 0.0,\n        0.5, 0.5, 0.5, 1.0\n    );\n    return m.mat4.mul$(offset, m.mat4.mul$(projection, view));\n}\n\nfunction init(c) {\n    // Initialization of the variables we want to be able to change via UI.\n    this.uniforms = {\n        shadowBias: 0.005\n    };\n    this.slopeShadowBias = true;\n    this.lightRotationX = Math.PI / 4.0;\n    this.lightRotationY = Math.PI / 4.0;\n    this.shadowResolution = 1024;\n\n    // We need two views - one for viewing the scene like in previous exercises (this.view)\n    // and one for viewing the scene from the direction of the light (this.lightView).\n    // We wish to model directional \"sun\" light and thus choose an orthographic projection.\n    // Also, the viewport size does not depend on the render window but from the choice of\n    // this.shadowResolution. The latter view needs to be recreated upon any change\n    // of shadowResolution. We therefore create the view in an updateShadowResolution function.\n    this.view = c.models.View.perspective(c, 45, null, 0.01, 50);\n    var r = Math.PI / 6;\n    this.view.transform\n        .rotateY(r)\n        .rotateX(-r)\n        .translateForward(12);\n    updateShadowResolution.call(this, c);\n\n    // Furthermore we need a material (remember materials also determine the shader program\n    // to use) for the shadow pass.\n    this.lightMaterial = new c.models.Material();\n    this.lightMaterial.program = 'Render Shadow Map';\n\n    // Create GUI\n    ui.call(this, c);\n    // Create simple geometry for the scene\n    buildScene.call(this, c);\n}\n\n\nfunction renderScene(c) {\n    c.view(this.view);\n\n    // We need uniforms for the light parameters (shading), the z-buffer depth map from\n    // the first render pass and the shadow modelview/projection matrices.\n    // The latter are needed to transform vertices into the viewport of the light\n    // in order to compare them.\n    var ropts = {\n        uniforms: {\n            lightDirection: c.math.vec3.negate$(this.lightView.transform.forwardAxis()),\n            shadowViewProjection: shadowTransform.call(this, c),\n            shadowMap: this.lightView.activeBufferTexture('depth')\n        }\n    };\n\n    // We copy the remaining uniforms (i.e. shadowBias) into the ropts.uniforms dictionary.\n    for (var k in this.uniforms) {\n        ropts.uniforms[k] = this.uniforms[k];\n    }\n\n    // Finally, render all models with the respective ropts.\n    for (var i = 0; i < this.models.length; i++) {\n        this.models[i].render(c, ropts);\n    }\n}\n\nfunction renderShadowMap(c) {\n    // The light direction now is our \"camera\". We thus need to\n    // construct the view matrix for the current view which\n    // lets us render from the point of view of the light.\n    var tr = c.math.transform.create();\n    tr.rotateY(-this.lightRotationY).rotateX(-this.lightRotationX);\n    c.math.transform.copy(this.lightView.transform, tr);\n\n    // We set the current View to this.lightView.\n    // By doing so we internally switch the FBO and have\n    // thus bound another depth map and z-buffer.\n    c.view(this.lightView);\n\n    // Polygon offset against geometric aliasing\n    if (this.slopeShadowBias) {\n        c.gl.polygonOffset(1.1, 4.0);\n        c.gl.enable(c.gl.POLYGON_OFFSET_FILL);\n    }\n\n    // We render all models with the \"Render Shadow Map\" shader program\n    // (determined by this.lightMaterial).\n    for (var i = 0; i < this.models.length; i++) {\n        this.models[i].render(c, {\n            material: this.lightMaterial\n        });\n    }\n\n    // If polygonOffset is activated at all we need to deactivate it\n    // after this pass.\n    if (this.slopeShadowBias) {\n        c.gl.polygonOffset(0, 0);\n        c.gl.disable(c.gl.POLYGON_OFFSET_FILL);\n    }\n}\n\n\nfunction render(c) {\n    //// PASS 1: Render from the direction of the light.\n    renderShadowMap.call(this, c);\n\n    //// PASS 2: Render from the direction of the camera.\n    renderScene.call(this, c);\n}",
  "creationTime": "2014-10-13T17:41:46.792Z",
  "authors": [
    {
      "name": "Jesse van den Kieboom",
      "license": "CC BY",
      "year": 2014
    }
  ]
}